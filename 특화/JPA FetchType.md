## FetchType.LAZY (지연 로딩)

지연 로딩은 연관된 엔티티를 실제로 사용하는 시점에만 데이터베이스에서 로드하는 방식입니다.

### 작동 방식

1. `DiaryTag` 엔티티를 조회할 때, `diary` 필드에는 실제 `Diary` 객체가 아닌 프록시(proxy) 객체가 담깁니다.
2. 이 프록시 객체는 실제 데이터를 가지고 있지 않지만, 필요할 때 데이터베이스에서 실제 객체를 로드할 수 있는 참조를 가지고 있습니다.
3. 코드에서 `diaryTag.getDiary().getTitle()`과 같이 실제로 Diary의 속성에 접근할 때만 데이터베이스 쿼리가 실행됩니다.

### 장점

1. **메모리 효율성**: 필요한 데이터만 로드하므로 메모리 사용량이 줄어듭니다.
2. **초기 로딩 속도**: 연관 엔티티를 즉시 로드하지 않으므로 초기 로딩 시간이 단축됩니다.
3. **불필요한 데이터 로딩 방지**: 연관 엔티티를 사용하지 않는 경우 데이터베이스에서 로드하지 않습니다.

### 주의 사항

1. **LazyInitializationException**: 세션이 종료된 후에 지연 로딩을 시도하면 이 예외가 발생합니다. 이는 엔티티 매니저(EntityManager)나 세션이 닫힌 후에는 데이터베이스 연결을 사용할 수 없기 때문입니다.
2. **N+1 문제**: 여러 개의 엔티티를 순회하면서 각각의 지연 로딩된 연관 엔티티에 접근할 경우, 각 접근마다 추가 쿼리가 발생하여 성능 저하를 초래할 수 있습니다.
    
    ```java
    java
    복사
    // N+1 문제 예시
    List<DiaryTag> diaryTags = diaryTagRepository.findAll();
    for (DiaryTag diaryTag : diaryTags) {
        // 각 반복마다 추가 쿼리 발생
        String diaryTitle = diaryTag.getDiary().getTitle();
    }
    
    ```
    

### FetchType.EAGER와의 비교

반대 개념인 `FetchType.EAGER`(즉시 로딩)은:

1. 엔티티를 조회할 때 연관된 엔티티도 함께 로드합니다.
2. 단일 쿼리로 모든 데이터를 가져오므로 N+1 문제가 발생하지 않습니다.
3. 하지만 불필요한 데이터도 항상 로드하므로 메모리 사용량이 증가하고, 쿼리가 복잡해질 수 있습니다.

좀 더 쉽게 이해할 수 있게 설명해 드리겠습니다.

## 지연 로딩(LAZY)과 즉시 로딩(EAGER)의 개념

### 실생활 비유로 설명하면:

### 지연 로딩(LAZY)

도서관에서 책을 빌리는 상황을 생각해 보세요:

- 여러분이 "해리 포터 시리즈" 책을 빌리고 싶다고 가정합니다
- **지연 로딩** 방식에서는, 우선 책 목록만 가져옵니다 ("해리 포터와 마법사의 돌", "해리 포터와 비밀의 방" 등의 제목만)
- 실제로 특정 책의 내용을 읽고 싶을 때만 해당 책을 서가에서 꺼내옵니다
- 즉, 책 제목을 보기만 할 때는 실제 책 내용은 가져오지 않고, 내용을 읽으려 할 때만 실제 책을 가져옵니다

### 즉시 로딩(EAGER)

같은 도서관 상황에서:

- **즉시 로딩** 방식에서는, 처음에 책 목록을 요청할 때 모든 책의 내용까지 한꺼번에 가져옵니다
- 해리 포터 시리즈의 모든 책과 그 내용을 한 번에 다 가져오는 것입니다
- 책 제목만 보려고 해도 모든 책의 전체 내용이 함께 옵니다

### 코드로 설명하면:

```java
java
복사
// DiaryTag가 Diary와 연결되어 있는 상황

// 지연 로딩(LAZY) 사용 시
DiaryTag tag = diaryTagRepository.findById(1);
// 이 시점에서는 tag 정보만 불러오고 diary 정보는 불러오지 않음

// 이 줄을 실행할 때 비로소 diary 정보를 데이터베이스에서 불러옴
String diaryTitle = tag.getDiary().getTitle();

```

```java
java
복사
// 즉시 로딩(EAGER) 사용 시
DiaryTag tag = diaryTagRepository.findById(1);
// 이 시점에서 이미 tag 정보와 함께 diary 정보도 모두 불러온 상태

// 이미 메모리에 있는 정보를 사용하므로 추가 데이터베이스 조회 없음
String diaryTitle = tag.getDiary().getTitle();

```

### 장단점 요약

**지연 로딩(LAZY)**

- **장점**: 필요한 데이터만 가져오므로 메모리와 초기 로딩 시간을 절약할 수 있습니다.
- **단점**: 나중에 데이터에 접근할 때 추가 데이터베이스 조회가 필요하므로, 여러 개체에 반복 접근하면 느려질 수 있습니다.

**즉시 로딩(EAGER)**

- **장점**: 나중에 데이터에 접근할 때 추가 조회가 필요 없어 빠릅니다.
- **단점**: 필요하지 않은 데이터까지 모두 가져오므로 메모리 사용량이 증가하고 초기 로딩 시간이 길어질 수 있습니다.

대부분의 경우 지연 로딩(LAZY)을 사용하는 것이 효율적이지만, 항상 함께 사용되는 관련 데이터라면 즉시 로딩(EAGER)이 더 효율적일 수 있습니다.

FetchType.LAZY를 사용하면, DiaryTag만 조회하고 연결된 Diary는 아직 조회하지 않는 상태로 둡니다. 이렇게 하면 처음에 필요한 데이터만 가져와서 시스템 자원을 효율적으로 사용할 수 있습니다.

그런데 이후에 코드에서 `diaryTag.getDiary().getTitle()`처럼 실제로 Diary 정보가 필요해지는 시점이 되면, 그때 JPA가 자동으로 추가 쿼리를 실행해서 Diary 정보를 데이터베이스에서 가져옵니다. 이런 방식을 "지연 로딩"이라고 합니다.

반면 FetchType.EAGER를 사용하면, DiaryTag를 조회할 때 연결된 Diary 정보까지 한 번에 모두 가져옵니다. 나중에 Diary 정보가 필요하지 않더라도 무조건 함께 로딩하기 때문에, 데이터가 많을 경우 메모리를 더 많이 사용하게 됩니다.

두 방식의 선택은 애플리케이션의 특성에 따라 달라집니다:

- 거의 항상 연관 엔티티의 정보가 필요하다면 EAGER가 효율적일 수 있습니다
- 가끔만 연관 엔티티 정보가 필요하거나, 조건에 따라 필요할 때만 LAZY가 효율적입니다

JPA에서는 일반적으로 @ManyToOne 관계에서는 EAGER가 기본값이고, @OneToMany나 @ManyToMany 관계에서는 LAZY가 기본값입니다. 하지만 성능 최적화를 위해 개발자가 직접 설정을 변경하는 경우가 많습니다.